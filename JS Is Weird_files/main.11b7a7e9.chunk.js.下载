(this["webpackJsonpjavascript-challenge"]=this["webpackJsonpjavascript-challenge"]||[]).push([[0],{17:function(e,t,s){},18:function(e,t,s){},19:function(e,t,s){"use strict";s.r(t);var r=s(1),n=s.n(r),o=s(9),i=s.n(o),a=s(3),c=s(5),l=[{question:"true + false",options:['"truefalse"',"1","NaN","SyntaxError"],correctAnswer:1,explanation:"Text",code:"bla"},{question:"[,,,].length",options:["0","3","4","SyntaxError"],correctAnswer:1},{question:"[1, 2, 3] + [4, 5, 6]",options:['"123456"','"1,2,34,5,6"','"1,2,3,4,5,6"',"NaN"],correctAnswer:1},{question:"0.2 + 0.1 === 0.3",options:["true","false","NaN","SyntaxError"],correctAnswer:1},{question:"10,2",options:["10.2","10","2","20"],correctAnswer:2},{question:'!!""',options:["true","false","undefined","SyntaxError"],correctAnswer:1},{question:"+!![]",options:["true","false","0","1"],correctAnswer:3},{question:"!!!true",options:["true","false","0","SyntaxError"],correctAnswer:1},{question:'true == "true"',options:["true","false","undefined","SyntaxError"],correctAnswer:1},{question:"010 - 03",options:["7","5","3","NaN"],correctAnswer:1},{question:'"" - - ""',options:['""',"0","NaN","SyntaxError"],correctAnswer:1},{question:"null + 0",options:["0",'"null0"',"NaN","TypeError"],correctAnswer:0},{question:"0/0",options:["0","Infinity","NaN","SyntaxError"],correctAnswer:2},{question:"1/0 > Math.pow(10, 1000)",options:["true","false","NaN","SyntaxError"],correctAnswer:1},{question:"true++",options:["2","undefined","NaN","SyntaxError"],correctAnswer:3},{question:'"" - 1',options:['"1"','"-1"',"-1","NaN"],correctAnswer:2},{question:'(null - 0) + "0"',options:['"null0"','"00"',"0","NaN"],correctAnswer:1},{question:'true + ("true" - 0)',options:["1","2","NaN","SyntaxError"],correctAnswer:2},{question:"!5 + !5",options:["0","10","25","NaN"],correctAnswer:0},{question:"[] + []",options:["[]","[,]",'""',"NaN"],correctAnswer:2},{question:"NaN === NaN",options:["true","false","TypeError","SyntaxError"],correctAnswer:1},{question:"NaN++",options:["NaN","undefined","TypeError","SyntaxError"],correctAnswer:0},{question:"undefined + false",options:['"undefinedfalse"',"0","NaN","SyntaxError"],correctAnswer:2},{question:"+0 === -0",options:["true","false","TypeError","SyntaxError"],correctAnswer:0},{question:'- "" + + "1" * null - [,]',options:["0",'"0"',"NaN","I give up"],correctAnswer:0}],d=s(4),h=s(0),j=function(e){return Object(h.jsx)("span",{className:"inline-code",children:e.children})},b=function(e){var t=e.url,s=e.text;return Object(h.jsx)("a",{href:t,target:"_blank",rel:"noreferrer",children:s})},u=function(e){var t=e.question,s=Object(h.jsx)("span",{});switch(t){case"0.2 + 0.1 === 0.3":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["This is a dilemma of comparing floating-point values. Instead of comparing two floating points directly, one should compare the floating points with some level of tolerance. ",Object(h.jsx)(b,{url:"https://stackoverflow.com/questions/588004/is-floating-point-math-broken",text:"This StackOverflow answer"})," explains this problem in greater detail."]}),Object(h.jsxs)("code",{children:["0.2 + 0.1; // -> 0.30000000000000004;",Object(h.jsx)("br",{}),"0.2 + 0.1 > 0.3; // -> true"]})]});break;case"0.3 + 0 === 0.3":s=Object(h.jsx)(h.Fragment,{children:Object(h.jsx)("p",{children:"This question is just a red herring; there's nothing unusual going on here."})});break;case"[] + []":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"This question is closely tied to question 3. Again, the extremely simplified answer is that JavaScript converts the arrays to strings. Scroll up to question 3 to find resources that explain this behavior."}),Object(h.jsxs)("code",{children:['[].toString(); // -> ""',Object(h.jsx)("br",{}),'"" + ""; // -> ""']}),Object(h.jsx)("p",{children:"Also, like I mentioned in the explanation for question 2, these expressions are equal, due to trailing commas:"}),Object(h.jsx)("code",{children:"[] + [] === [,] + [,]; // -> true"}),Object(h.jsx)("p",{children:"Even though these arrays are different, they are both converted to empty strings:"}),Object(h.jsxs)("code",{children:["[].length; // -> 0",Object(h.jsx)("br",{}),"[,].length; // -> 1",Object(h.jsx)("br",{}),"[].toString() === [,].toString(); // -> true"]}),Object(h.jsx)("p",{children:"Of course, this is also true:"}),Object(h.jsx)("code",{children:"Number([]) === Number([,]); // -> true"})]});break;case"NaN === NaN":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["This is due to a decision made by the IEEE-754 committee for a few reasons, such as space efficiency and the fact that the function ",Object(h.jsx)(j,{children:"isNaN"})," didn't exist at the time. See ",Object(h.jsx)(b,{text:"Stephen Canon's explanation",url:"https://stackoverflow.com/questions/1565164/what-is-the-rationale-for-all-comparisons-returning-false-for-ieee754-nan-values#1573715"})," for why NaN isn't equal to itself."]}),Object(h.jsx)("p",{children:"Also, while NaN may not be equal to itself..."}),Object(h.jsx)("code",{children:"NaN === NaN; // -> false"}),Object(h.jsx)("p",{children:"... these two statements are true."}),Object(h.jsxs)("code",{children:["isNaN(NaN); // -> true",Object(h.jsx)("br",{}),"Object.is(NaN, NaN); // -> true"]})]});break;case"+0 === -0":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["Positive zero and negative zero are equal in JavaScript. Interestingly, though, the ",Object(h.jsx)(j,{children:"Object.is"})," function disagrees. There are a few scenarios where ",Object(h.jsx)(j,{children:"==="})," and ",Object(h.jsx)(j,{children:"Object.is"})," disagree with one another, and this is one of them."]}),Object(h.jsx)("code",{children:"Object.is(0, -0); // -> false"})]});break;case"true + false":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["This question sets the tone for many of the upcoming questions. All four options may sound quite reasonable for someone who does not already know the answer. The short answer is that the booleans are converted to their numeric representations. Learn more in the ",Object(h.jsx)(b,{url:"https://262.ecma-international.org/5.1/#sec-11.6",text:"ECMAScript Language Specification"}),"."]}),Object(h.jsxs)("code",{children:["Number(true); // -> 1",Object(h.jsx)("br",{}),"Number(false); // -> 0",Object(h.jsx)("br",{}),"1 + 0; // -> 1"]})]});break;case"[,,,].length":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:[Object(h.jsx)(j,{children:"[,,,]"})," outputs an array with three empty slots. The last comma is a ",Object(h.jsx)(b,{text:"trailing comma",url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas"}),"."]}),Object(h.jsx)("p",{children:"If you don't think this is weird enough yet, then take a look at this:"}),Object(h.jsxs)("code",{children:['[,] + [,]; // -> ""',Object(h.jsx)("br",{}),"[] + [] === [,] + [,]; // -> true",Object(h.jsx)("br",{}),'[,,,] + [,,,]; // -> ",,,,"',Object(h.jsx)("br",{}),"([,,,] + [,,,]).length === [,,,,].length; // -> true"]}),Object(h.jsx)("p",{children:"To find resources that explain the addition operator with arrays, take a look at the explanation for question 3, directly below this."})]});break;case"[1, 2, 3] + [4, 5, 6]":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["The extremely simplified answer is that the arrays are converted to strings and are then concatenated. See ",Object(h.jsx)(b,{text:"Denys Dovhan's explanation",url:"https://github.com/denysdovhan/wtfjs#adding-arrays"})," for how this happens. To learn more about this behavior, visit ",Object(h.jsx)(b,{url:"https://stackoverflow.com/questions/9032856/what-is-the-explanation-for-these-bizarre-javascript-behaviours-mentioned-in-the",text:"this StackOverflow answer"})," for a mid-level explanation or ",Object(h.jsx)(b,{text:"this blog post",url:"https://2ality.com/2012/01/object-plus-object.html"})," for a more detailed one."]}),Object(h.jsx)("p",{children:"Adding a trailing comma doesn't change anything, by the way:"}),Object(h.jsx)("code",{children:'[1, 2, 3,] + [4, 5, 6]; // -> "1,2,34,5,6"'}),Object(h.jsx)("p",{children:"But, I suppose, if you really want to convert your arrays to comma-separated strings and combine them, you could write something stupid like this:"}),Object(h.jsx)("code",{children:'[1, 2, 3] + [, 4, 5, 6]; // -> "1,2,3,4,5,6"'}),Object(h.jsx)("p",{children:"Or, even dumber, this:"}),Object(h.jsx)("code",{children:'[1, 2, 3, ""] + [4, 5, 6]; // -> "1,2,3,4,5,6"'}),Object(h.jsx)("p",{children:"Probably best not to use the addition operator together with arrays, though. If you do want to combine two arrays for real, this is a better approach:"}),Object(h.jsx)("code",{children:"[...[1, 2, 3], ...[4, 5, 6]];"})]});break;case'!!""':s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:'You can add two exclamation marks before any value to get its boolean representation. Usually, anything with a value is true, and anything with an "empty" value is false.'}),Object(h.jsxs)("code",{children:['Boolean(""); // -> false',Object(h.jsx)("br",{}),"Boolean(0); // -> false",Object(h.jsx)("br",{}),'Boolean("Pineapple"); // -> true',Object(h.jsx)("br",{}),"Boolean(42); // -> true"]})]});break;case"+!![]":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"In the explanation above, I mentioned that empty values are usually represented by the boolean false. An empty array is an exception, however. It's represented by true. The plus character then converts true to its numeric representation."}),Object(h.jsxs)("code",{children:["Boolean([]); // -> true",Object(h.jsx)("br",{}),"Number(true); // -> 1"]})]});break;case"!!!true":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"It's incredibly unusual to put three or more exclamation marks in a row, so you may not realize that it is something you can even do."}),Object(h.jsx)("p",{children:"But why stop at only three when you could write incredibly unreadable code?"}),Object(h.jsx)("code",{children:"!!!!!!!!!!!!true; // -> true"})]});break;case'true == "true"':s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["According to the rules of ",Object(h.jsx)(b,{text:"abstract equality comparison",url:"https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison"}),", both of these values are converted to numbers."]}),Object(h.jsxs)("code",{children:["Number(true); // -> 1",Object(h.jsx)("br",{}),'Number("true"); // -> NaN',Object(h.jsx)("br",{}),"1 == NaN; // -> false"]})]});break;case"010 - 03":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["010 is treated as an octal number by JavaScript. Thus, its value is in base 8. ",Object(h.jsx)(b,{text:"See Mozilla's explanation for octal numbers",url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_dates#octal_numbers"}),"."]}),Object(h.jsxs)("code",{children:["010; // -> 8",Object(h.jsx)("br",{}),"03; // -> 3",Object(h.jsx)("br",{}),"8 - 3; // -> 5"]}),Object(h.jsx)("p",{children:"You can go all out with octal numbers, if you'd like:"}),Object(h.jsx)("code",{children:"01111111111111111; // -> 40210710958665"}),Object(h.jsx)("p",{children:"By the way, the number of leading zeroes doesn't matter:"}),Object(h.jsx)("code",{children:"010 === 0000000010; // -> true"})]});break;case"false * 2":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"The multiplication operator makes it clear to JS that false should be converted to a number."}),Object(h.jsxs)("code",{children:["Number(false); // -> 0",Object(h.jsx)("br",{}),"0 * 2; // -> 0"]})]});break;case"undefined + false":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"While false can be converted to a number, undefined cannot."}),Object(h.jsxs)("code",{children:["Number(false); // -> 0",Object(h.jsx)("br",{}),"Number(undefined); // -> NaN",Object(h.jsx)("br",{}),"NaN + 0; // -> NaN"]}),Object(h.jsxs)("p",{children:["However, undefined ",Object(h.jsx)("i",{children:"is"})," represented by false:"]}),Object(h.jsx)("code",{children:"!!undefined === false; // -> true"}),Object(h.jsx)("p",{children:"Which means that we can add undefined and false like so:"}),Object(h.jsx)("code",{children:"!!undefined + false; // -> 0"})]});break;case"null + 0":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"Null converts to its numeric representation: 0."}),Object(h.jsxs)("code",{children:["Number(null); // -> 0",Object(h.jsx)("br",{}),"0 + 0; // -> 0"]}),Object(h.jsx)("p",{children:"This also means that while..."}),Object(h.jsx)("code",{children:"null === false; // -> false"}),Object(h.jsx)("p",{children:"... this is true:"}),Object(h.jsx)("code",{children:"+null === +false; // -> true"})]});break;case"0/0":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["As there is no meaningful numerical answer to the equation 0/0, the output is simply ",Object(h.jsx)(j,{children:"NaN"}),"."]}),Object(h.jsx)("code",{children:"isNaN(0/0); // -> true"})]});break;case"1/0 > Math.pow(10, 1000)":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["JavaScript treats both of these values as infinite, and infinity is equal to infinity. ",Object(h.jsx)(b,{text:"Learn more about infinities",url:"https://en.wikipedia.org/wiki/Floating-point_arithmetic#Infinities"}),"."]}),Object(h.jsxs)("code",{children:["1/0; // -> Infinity",Object(h.jsx)("br",{}),"Math.pow(10, 1000); // -> Infinity",Object(h.jsx)("br",{}),"Infinity > Infinity; // -> false"]})]});break;case"NaN++":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"Attempting to increment NaN will simply output NaN."}),Object(h.jsxs)("code",{children:["let _NaN = NaN;",Object(h.jsx)("br",{}),"_NaN++;",Object(h.jsx)("br",{}),"isNaN(_NaN); // -> true",Object(h.jsx)("br",{}),"_NaN--;",Object(h.jsx)("br",{}),"isNaN(_NaN); // -> true",Object(h.jsx)("br",{}),"_NaN *= 10;",Object(h.jsx)("br",{}),"isNaN(_NaN); // -> true"]})]});break;case"true++":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"Our first and only syntax error. I put SyntaxError as an option on a lot of the questions, hoping that some users would find some syntax so bizarre that it could not possibly be allowed. So, I felt that I had to add at least one expression that actually does result in a SyntaxError."}),Object(h.jsxs)("p",{children:["By the way, ",Object(h.jsx)(j,{children:"undefined++"})," does not result in a SyntaxError:"]}),Object(h.jsxs)("code",{children:["1++; // -> SyntaxError",Object(h.jsx)("br",{}),'"x"++; // -> SyntaxError',Object(h.jsx)("br",{}),"undefined++; // -> NaN"]}),Object(h.jsx)("p",{children:"And, of course, just to be completely clear, this is valid syntax:"}),Object(h.jsxs)("code",{children:["let _true = true;",Object(h.jsx)("br",{}),"_true++;",Object(h.jsx)("br",{}),"_true; // -> 2"]})]});break;case'"" - - ""':s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"These two empty strings are both converted to 0."}),Object(h.jsxs)("code",{children:['Number(""); // -> 0',Object(h.jsx)("br",{}),"0 - - 0; // -> 0"]}),Object(h.jsx)("p",{children:"The expression might become a bit clearer if I write it like this:"}),Object(h.jsxs)("code",{children:['+"" - -"";',Object(h.jsx)("br",{}),"+0 - -0;"]}),Object(h.jsx)("p",{children:"Please note that, while I put the space between the minus sign and the empty string simply to attempt to confuse you, the space between the minus signs themselves is important:"}),Object(h.jsxs)("code",{children:['- -""; // -> 0',Object(h.jsx)("br",{}),'--""; // -> SyntaxError']})]});break;case'"" - 1':s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"While the addition operator (+) is used both for numbers and strings, the subtraction operator (-) has no use for strings, so JavaScript interprets this as an operation between numbers. An empty string converts to 0."}),Object(h.jsxs)("code",{children:['Number(""); // -> 0',Object(h.jsx)("br",{}),"0 - 1; // -> -1;"]}),Object(h.jsx)("p",{children:"This would still be true even if the string had a space (or more) inside of it:"}),Object(h.jsx)("code",{children:'" " - 1; // -> -1;'}),Object(h.jsx)("p",{children:"However, if we use the addition operator, then string concatenation takes priority:"}),Object(h.jsx)("code",{children:'"" + 1; // -> "1";'})]});break;case'(null - 0) + "0"':s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("code",{children:["Number(null) - 0; // -> 0",Object(h.jsx)("br",{}),'0 + "0"; // -> "00"']}),Object(h.jsx)("p",{children:"But if the question had used only the subtraction operator, the result would have been different:"}),Object(h.jsx)("code",{children:'(null - 0) - "0"; // -> 0'})]});break;case'true + ("true" - 0)':s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"You might suspect that JS is so bananas that it would convert the string literal to its boolean value and then its numerical representation. It's not quite that bananas, however. What actually happens is that it tries to convert the string to a number and fails."}),Object(h.jsx)("code",{children:'Number("true"); // -> NaN'})]});break;case"10,2":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsxs)("p",{children:["The ",Object(h.jsx)(b,{text:"comma operator",url:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator"})," simply returns the value of the last operand."]}),Object(h.jsxs)("code",{children:["10, 2; // -> 2",Object(h.jsx)("br",{}),"1, 2, 3, 4; // -> 4",Object(h.jsx)("br",{}),'42, "pineapple", true; // -> true']})]});break;case"!5 + !5":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"All positive numbers are represented by the boolean true. The opposite of true is false, and false converts to 0."}),Object(h.jsxs)("code",{children:["Boolean(5); // -> true",Object(h.jsx)("br",{}),"!true; // -> false",Object(h.jsx)("br",{}),"Number(false); // -> 0",Object(h.jsx)("br",{}),"0 + 0; // -> 0"]})]});break;case"+Infinity === -Infinity":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"Infinity may be equal to infinity, but negative and positive infinities are not."}),Object(h.jsx)("code",{children:"Number.POSITIVE_INFINITY === Number.NEGATIVE_INFINITY; // -> false"})]});break;case"undefined === undefined":s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"This is a red herring. The output is what you would probably expect."}),Object(h.jsx)("p",{children:"But would you have expected this?"}),Object(h.jsx)("code",{children:"undefined++ === undefined++; // -> false"}),Object(h.jsxs)("p",{children:["As I mentioned in the explanation for question 15, ",Object(h.jsx)(j,{children:"undefined++"})," outputs ",Object(h.jsx)(j,{children:"NaN"}),". Thus, this is false because ",Object(h.jsx)(j,{children:"NaN !== NaN"}),", as we learned in question 21."]})]});break;case'!!"JS is weird"':s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"I feel like I should have accepted all four options as a correct answer for comedic effect, so sorry if your perfect score was shattered if you argued that this statement is only maybe true."}),Object(h.jsx)("code",{children:'Boolean("JS is weird"); // -> true'})]});break;case'- "" + + "1" * null - [,]':s=Object(h.jsxs)(h.Fragment,{children:[Object(h.jsx)("p",{children:"The finale wraps up much of the bizarre syntax that I've covered in this quiz. Let's break it down, piece by piece:"}),Object(h.jsxs)("code",{children:['-""; // -> -0',Object(h.jsx)("br",{}),'+"1"; // -> 1',Object(h.jsx)("br",{}),"Number(null); // -> 0",Object(h.jsx)("br",{}),"Number([,]); // -> 0",Object(h.jsx)("br",{})]}),Object(h.jsx)("p",{children:"Add it all together:"}),Object(h.jsx)("code",{children:"-0 + 1 * 0 - 0; // -> 0"})]});break;case"copy":s=Object(h.jsx)(h.Fragment,{})}return Object(h.jsx)(h.Fragment,{children:s})},p=function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];console.clear(),e?console.log("%cWhat, are you going to check if the results are accurate? Go ahead \ud83d\udc81\u200d\u2642\ufe0f","background-color: #E22134; padding: 0.3rem 1.5rem; font-family: Roboto; font-size: 1.2em; line-height: 1.4em; color: white;"):console.log("%cHey, stop cheating! \ud83d\ude20","background-color: #E22134; padding: 0.3rem 1.5rem; font-family: Roboto; font-size: 1.2em; line-height: 1.4em; color: white;"),console.log("%cBtw, while you're here, did you know that you can add CSS to console.log()? \ud83d\ude04","background-color: #003366; padding: 0.3rem 1.5rem; font-family: Roboto; font-size: 1.2em; line-height: 1.4em; color: white;"),console.log("%cI wrote about it here \ud83d\udc49 https://javascript.plainenglish.io/adding-css-to-console-log-dde2e167ee7a","background-color: #065535; padding: 0.3rem 1.5rem; font-family: Roboto; font-size: 1.2em; line-height: 1.4em; color: white;"),console.log("%cAnd here \ud83d\udc49 https://javascript.plainenglish.io/a-prettier-console-log-786f46d0bc3c","background-color: #065535; padding: 0.3rem 1.5rem; font-family: Roboto; font-size: 1.2em; line-height: 1.4em; color: white;"),console.log("%cIt barely works in FireFox though, someone please ask Mozilla to fix it; this is important \ud83d\udc85","padding: 0.3rem 1.5rem; font-family: Roboto; font-size: 1.2em; line-height: 1.4em; color: white; background: rgb(131,58,180); background: linear-gradient(90deg, rgba(131,58,180,1) 0%, rgba(253,29,29,1) 50%, rgba(252,176,69,1) 100%);"),e||console.log("%cType answers to get all answers \ud83d\udc47","padding: 0.3rem 1.5rem; font-family: Roboto; font-size: 1.2em; line-height: 1.4em; font-style: italic; border: 2px solid black;")},x={INITIAL:0,QUIZ_START_ANIMATION1:1,QUIZ_START_ANIMATION2:2,QUIZ_STARTED_ANIMATION:3,QUIZ_STARTED:4,QUIZ_END_ANIMATION1:5,QUIZ_END_ANIMATION2:6,QUIZ_RESULTS_ANIMATION:7,QUIZ_RESULTS:8},O=function(){var e=Object(r.useState)(x.INITIAL),t=Object(c.a)(e,2),s=t[0],n=t[1],o=Object(r.useState)(null),i=Object(c.a)(o,2),j=i[0],O=i[1],m=Object(r.useState)(0),f=Object(c.a)(m,2),g=f[0],N=f[1],y=Object(r.useState)(l.length),w=Object(c.a)(y,2),v=w[0],I=(w[1],Object(r.useState)([])),A=Object(c.a)(I,2),T=A[0],S=A[1],k=function(){n(x.QUIZ_END_ANIMATION2),setTimeout((function(){p(!0),n(x.QUIZ_RESULTS_ANIMATION),setTimeout((function(){n(x.QUIZ_RESULTS)}),500)}),500)};if(s<=x.QUIZ_START_ANIMATION2){document.body.classList.contains("no-overflow")||document.body.classList.add("no-overflow");var q="no-overflow quiz-wrapper"+(s===x.QUIZ_START_ANIMATION1?" skew":s===x.QUIZ_START_ANIMATION2?" slide-out":"");return Object(h.jsxs)("div",{className:q,children:[Object(h.jsx)("h1",{children:"JS Is Weird"}),Object(h.jsx)("p",{className:"stylized-paragraph",children:"JavaScript is a great programming language, but thanks to the fact that its initial release was built in only ten days back in 1995, coupled with the fact that JS is backward-compatible, it's also a bit weird. It doesn't always behave the way you might think. In this quiz, you'll be shown 25 quirky expressions and will have to guess the output. Even if you're a JS developer, most of this syntax is probably, and hopefully, not something you use in your daily life."}),Object(h.jsx)("div",{className:"button-wrapper",children:Object(h.jsx)("button",{onClick:function(){return p(!1),n(x.QUIZ_START_ANIMATION2),setTimeout((function(){n(x.QUIZ_STARTED_ANIMATION),setTimeout((function(){n(x.QUIZ_STARTED)}),500)}),500),O(l[0]),N(0),void S([])},children:"Let's start"})})]})}if(s<=x.QUIZ_END_ANIMATION2){var _=j.options.map((function(e,t){return Object(h.jsx)("button",{onClick:function(){return function(e){S([].concat(Object(a.a)(T),[e]));var t=g+1;t<v?(N(t),O(l[t])):k()}(t)},className:"no-select",children:Object(h.jsx)(d.a,{text:e,springConfig:d.b.stiff,noOverflow:!0})},t)})),E="no-overflow quiz-wrapper quiz-active"+(s===x.QUIZ_STARTED_ANIMATION?" slide-in-init slide-in":s===x.QUIZ_END_ANIMATION1?" skew":s===x.QUIZ_END_ANIMATION2?" slide-out":""),F="progress"+(s===x.QUIZ_STARTED_ANIMATION?" progress-animation-one":s===x.QUIZ_STARTED?" progress-animation-one progress-animation-two":"");return Object(h.jsxs)("div",{className:E,children:[Object(h.jsx)("h1",{children:Object(h.jsx)(d.a,{text:j.question,springConfig:d.b.stiff,noOverflow:!0})}),Object(h.jsx)("div",{className:"button-wrapper",children:_}),Object(h.jsxs)("div",{className:F,children:[Object(h.jsx)("span",{className:"margin-right",children:"Question"}),Object(h.jsx)("div",{className:"margin-right",children:Object(h.jsx)(d.a,{text:g+1,springConfig:d.b.stiff,noOverflow:!0})}),Object(h.jsx)("span",{className:"margin-right",children:"of"}),Object(h.jsx)("span",{children:v})]})]})}document.body.classList.contains("no-overflow")&&document.body.classList.remove("no-overflow");var U=function(){for(var e=[],t=0,s=0;s<v;s++){var r=l[s],n=r.correctAnswer===T[s];e.push({question:r.question,correctAnswer:r.options[r.correctAnswer],userAnswer:r.options[T[s]],wasUserRight:n,index:s,explanation:r.explanation,code:r.code}),n&&(t+=1)}return[e,t]}(),z=Object(c.a)(U,2),R=z[0],M=z[1],Q=R.map((function(e){return Object(h.jsxs)("li",{className:"result-item ".concat(e.wasUserRight?"answered-correctly":"answered-incorrectly"),children:[Object(h.jsxs)("span",{className:"result-question",children:[e.index+1,". ",e.question]}),Object(h.jsxs)("div",{className:"result-item-inner-wrapper",children:[Object(h.jsxs)("span",{className:"result-correct-answer",children:["Output: ",Object(h.jsx)("span",{children:e.correctAnswer})]}),Object(h.jsxs)("span",{className:"result-user-answer",children:["You answered: ",Object(h.jsx)("span",{children:e.userAnswer})]}),e.wasUserRight?Object(h.jsx)("span",{className:"inline-answer answered-correctly",children:"You got it right!"}):Object(h.jsx)("span",{className:"inline-answer answered-incorrectly",children:"You answered incorrectly."}),Object(h.jsx)(u,{question:e.question})]})]},e.index)})),Z="quiz-wrapper results-wrapper"+(s>=x.QUIZ_RESULTS_ANIMATION?" show":"");return Object(h.jsxs)("div",{className:Z,children:[Object(h.jsxs)("h1",{children:["You got ",M," out of ",v," correct!"]}),Object(h.jsx)("ul",{className:"results-list",children:Q}),Object(h.jsxs)("p",{className:"stylized-paragraph stylized-paragraph-wide",children:["I hope you thought this little quiz was fun, and, hopefully, you even learned something new. This quiz was made by ",Object(h.jsx)(b,{text:"Jacob Bergdahl",url:"https://jacobbergdahl.com/"}),". If you have any suggestions, corrections, or feedback, do send me an ",Object(h.jsx)("a",{href:"mailto:thisisrealai@gmail.com",children:"e-mail"}),". I'm sure I've made some mistakes! If you want more of this, I'd recommend checking out ",Object(h.jsx)(b,{text:"this GitHub repository by Denys Dovhan",url:"https://github.com/denysdovhan/wtfjs"}),", which is full of funny and tricky JavaScript examples. This repository is part of what inspired me to create this quiz. If you want to go deeper, you can always grab a lantern and head into the ",Object(h.jsx)(b,{text:"depths of the ECMAScript publications",url:"https://www.ecma-international.org/publications-and-standards/standards/"}),". Have fun in there!"]}),Object(h.jsx)("div",{className:"button-wrapper",children:Object(h.jsx)("button",{onClick:function(){n(x.INITIAL)},children:"Start over"})})]})};var m=function(){return document.body.addEventListener("keydown",(function(e){if(9===e.keyCode){var t=document.getElementsByClassName("button-wrapper");t&&t[0]&&t[0].classList.add("tab-mode")}})),Object(h.jsx)("div",{className:"App",children:Object(h.jsx)(O,{})})};s(17),s(18);i.a.render(Object(h.jsx)(n.a.StrictMode,{children:Object(h.jsx)(m,{})}),document.getElementById("root"))}},[[19,1,2]]]);
//# sourceMappingURL=main.11b7a7e9.chunk.js.map